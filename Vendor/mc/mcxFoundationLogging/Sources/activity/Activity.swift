//
//  Activity.swift
//  WaveLabs
//
//  Created by Vlad Gorlov on 06.05.18.
//  Copyright Â© 2018 Vlad Gorlov. All rights reserved.
//

import Foundation
import os.activity

// See - https://gist.github.com/zwaldowski/49f61292757f86d7d036a529f2d04f0c

// Bridging Obj-C variabled defined as c-macroses. See `activity.h` header.
private let osActivityNoneSymbol = dlsym(UnsafeMutableRawPointer(bitPattern: -2), "_os_activity_none")
private let osActivityCurrecntSymbol = dlsym(UnsafeMutableRawPointer(bitPattern: -2), "_os_activity_current")

public struct Activity {

   private let activity: OS_os_activity!

   public init(_ description: StaticString, dso: UnsafeRawPointer? = #dsohandle, options: Options = []) {
      activity = description.withUTF8Buffer {
         if let dso = UnsafeMutableRawPointer(mutating: dso), let address = $0.baseAddress {
            let str = UnsafeRawPointer(address).assumingMemoryBound(to: Int8.self)
            return _os_activity_create(dso, str, Activity.osActivityCurrecnt, os_activity_flag_t(rawValue: options.rawValue))
         } else {
            return nil
         }
      }
   }

   public init(_ description: StaticString, dso: UnsafeRawPointer? = #dsohandle, parent: Activity, options: Options = []) {
      let parentActivity: OS_os_activity = parent.activity != nil ? parent.activity : Activity.osActivityCurrecnt
      activity = description.withUTF8Buffer {
         if let dso = UnsafeMutableRawPointer(mutating: dso), let address = $0.baseAddress {
            let str = UnsafeRawPointer(address).assumingMemoryBound(to: Int8.self)
            return _os_activity_create(dso, str, parentActivity, os_activity_flag_t(rawValue: options.rawValue))
         } else {
            return nil
         }
      }
   }

   private init(_ activity: OS_os_activity) {
      self.activity = activity
   }
}

extension Activity {

   private static let osActivityNone = unsafeBitCast(osActivityNoneSymbol, to: OS_os_activity.self)
   private static let osActivityCurrecnt = unsafeBitCast(osActivityCurrecntSymbol, to: OS_os_activity.self)

   public static var none: Activity {
      return Activity(osActivityNone)
   }

   public static var current: Activity {
      return Activity(osActivityCurrecnt)
   }

   public static func initiate(_ description: StaticString, dso: UnsafeRawPointer? = #dsohandle, options: Options = [],
                               execute body: @convention(block) () -> Void) {
      description.withUTF8Buffer {
         if let dso = UnsafeMutableRawPointer(mutating: dso), let address = $0.baseAddress {
            let str = UnsafeRawPointer(address).assumingMemoryBound(to: Int8.self)
            _os_activity_initiate(dso, str, os_activity_flag_t(rawValue: options.rawValue), body)
         }
      }
   }

   public static func enter(_ description: StaticString, dso: UnsafeRawPointer? = #dsohandle, options: Options = []) -> Scope {
      let activity = Activity(description, dso: dso, options: options)
      return activity.enter()
   }

   public func apply(execute body: @convention(block) () -> Void) {
      if activity != nil {
         os_activity_apply(activity, body)
      }
   }

   public func enter() -> Scope {
      let scope = Scope()
      if activity != nil {
         os_activity_scope_enter(activity, &scope.state)
      }
      return scope
   }

   /**
    * Label an activity that is auto-generated by AppKit/UIKit with a name that is
    * useful for debugging macro-level user actions.  The API should be called
    * early within the scope of the IBAction and before any sub-activities are
    * created.
    * This API can only be called once and only on the activity created by AppKit/UIKit.
    */
   public static func labelUserAction(_ description: StaticString, dso: UnsafeRawPointer? = #dsohandle) {
      description.withUTF8Buffer {
         if let dso = UnsafeMutableRawPointer(mutating: dso), let address = $0.baseAddress {
            let str = UnsafeRawPointer(address).assumingMemoryBound(to: Int8.self)
            _os_activity_label_useraction(dso, str)
         }
      }
   }
}

extension Activity {

   public struct Options: OptionSet {

      public let rawValue: UInt32

      public init(rawValue: UInt32) {
         self.rawValue = rawValue
      }

      public static let `default` = Options(rawValue: OS_ACTIVITY_FLAG_DEFAULT.rawValue)
      public static let detached = Options(rawValue: OS_ACTIVITY_FLAG_DETACHED.rawValue)
      public static let ifNonePresent = Options(rawValue: OS_ACTIVITY_FLAG_IF_NONE_PRESENT.rawValue)
   }

   public class Scope {

      fileprivate var state = os_activity_scope_state_s()

      public func leave() {
         os_activity_scope_leave(&state)
      }
   }
}
